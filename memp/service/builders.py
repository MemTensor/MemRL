"""
Memory builders for different build strategies in the Memp system.

This module implements the Builder pattern for constructing procedural memories
according to different build strategies: Trajectory, Script, and Proceduralization.
"""

import logging
from abc import ABC, abstractmethod
from typing import Optional

from .strategies import BuildStrategy
from ..providers.base import BaseLLM

logger = logging.getLogger(__name__)


class MemoryBuilder(ABC):
    """
    Abstract base class for memory builders.

    Each builder implements a specific build strategy for creating
    procedural memory content from task trajectories.
    """

    def __init__(self, llm_provider: Optional[BaseLLM] = None):
        """
        Initialize the memory builder.

        Args:
            llm_provider: LLM provider for script generation (required for some strategies)
        """
        self.llm_provider = llm_provider

    @abstractmethod
    def build(self, task_description: str, trajectory: str) -> str:
        """
        Build memory content from task description and trajectory.

        Args:
            task_description: Natural language description of the task
            trajectory: Detailed step-by-step trajectory of task execution

        Returns:
            Memory content string formatted according to the build strategy

        Raises:
            RuntimeError: If memory building fails
        """
        pass

    def build_batch(self, td2traj: dict[str, str]) -> dict[str, str]:
        """
        串行批处理版本：默认对输入字典逐条调用 build()，避免并发带来的竞争问题。

        参数：
            td2traj: {task_description: trajectory}
        返回：
            {task_description: memory_content}
        说明：
            - 保持向后兼容：不改变单条 build() 的签名与语义
            - 子类如需并行优化，可自行重写，但请注意底层存储的并发约束
        """
        results: dict[str, str] = {}
        for task_description, trajectory in td2traj.items():
            results[task_description] = self.build(task_description, trajectory)
        return results


    @property
    @abstractmethod
    def strategy(self) -> BuildStrategy:
        """Return the build strategy this builder implements."""
        pass


class TrajectoryBuilder(MemoryBuilder):
    """
    Builder for Trajectory strategy.

    This strategy stores the complete trajectory as-is without any processing.
    It's the simplest strategy and serves as a baseline for comparison.
    """

    def build(self, task_description: str, trajectory: str) -> str:
        """
        Build memory content using Trajectory strategy.

        Args:
            task_description: Natural language description of the task
            trajectory: Detailed step-by-step trajectory of task execution

        Returns:
            The original trajectory content unchanged
        """
        logger.debug(f"Building trajectory memory for task: {task_description[:50]}...")
        return trajectory

    @property
    def strategy(self) -> BuildStrategy:
        """Return BuildStrategy.TRAJECTORY."""
        return BuildStrategy.TRAJECTORY


class ScriptBuilder(MemoryBuilder):
    """
    Builder for Script strategy.

    This strategy uses an LLM to generate a high-level script from the trajectory,
    creating a more abstract representation of the task completion process.
    """

    def __init__(self, llm_provider: BaseLLM):
        """
        Initialize the script builder.

        Args:
            llm_provider: LLM provider for script generation (required)

        Raises:
            ValueError: If llm_provider is None
        """
        if llm_provider is None:
            raise ValueError("ScriptBuilder requires an LLM provider")
        super().__init__(llm_provider)

    def build(self, task_description: str, trajectory: str) -> str:
        """
        Build memory content using Script strategy.

        Args:
            task_description: Natural language description of the task
            trajectory: Detailed step-by-step trajectory of task execution

        Returns:
            High-level script generated by the LLM

        Raises:
            RuntimeError: If script generation fails
        """
        try:
            logger.debug(f"Generating script for task: {task_description[:50]}...")
            script = self.llm_provider.generate_script(trajectory)
            logger.debug(f"Generated script: {script[:100]}...")
            return script
        except Exception as e:
            logger.error(f"Failed to generate script: {e}")
            raise RuntimeError(f"Script generation failed: {e}")

    @property
    def strategy(self) -> BuildStrategy:
        """Return BuildStrategy.SCRIPT."""
        return BuildStrategy.SCRIPT


class ProceduralizationBuilder(MemoryBuilder):
    """
    Builder for Proceduralization strategy.

    This strategy combines both the high-level script and the detailed trajectory,
    providing both abstract and concrete representations of the task completion.
    """

    def __init__(self, llm_provider: BaseLLM):
        """
        Initialize the proceduralization builder.

        Args:
            llm_provider: LLM provider for script generation (required)

        Raises:
            ValueError: If llm_provider is None
        """
        if llm_provider is None:
            raise ValueError("ProceduralizationBuilder requires an LLM provider")
        super().__init__(llm_provider)

    def build(self, task_description: str, trajectory: str) -> str:
        """
        Build memory content using Proceduralization strategy.

        Args:
            task_description: Natural language description of the task
            trajectory: Detailed step-by-step trajectory of task execution

        Returns:
            Combined content with both script and trajectory in the format:
            "SCRIPT:\n{script}\n\nTRAJECTORY:\n{trajectory}"

        Raises:
            RuntimeError: If script generation fails
        """
        try:
            logger.debug(f"Generating procedural memory for task: {task_description[:50]}...")
            script = self.llm_provider.generate_script(trajectory)
            logger.debug(f"Generated script: {script[:100]}...")

            # Combine script and trajectory in the expected format
            combined_content = f"SCRIPT:\n{script}\n\nTRAJECTORY:\n{trajectory}"

            logger.debug(f"Generated procedural content: {combined_content[:150]}...")
            return combined_content
        except Exception as e:
            logger.error(f"Failed to generate procedural memory: {e}")
            raise RuntimeError(f"Procedural memory generation failed: {e}")

    @property
    def strategy(self) -> BuildStrategy:
        """Return BuildStrategy.PROCEDURALIZATION."""
        return BuildStrategy.PROCEDURALIZATION


def get_builder(strategy: BuildStrategy, llm_provider: Optional[BaseLLM] = None) -> MemoryBuilder:
    """
    Factory method to create the appropriate memory builder for a given strategy.

    Args:
        strategy: The build strategy to use
        llm_provider: LLM provider (required for Script and Proceduralization strategies)

    Returns:
        Appropriate MemoryBuilder instance

    Raises:
        ValueError: If strategy is invalid or required LLM provider is missing
    """
    if strategy == BuildStrategy.TRAJECTORY:
        return TrajectoryBuilder(llm_provider)

    elif strategy == BuildStrategy.SCRIPT:
        if llm_provider is None:
            raise ValueError("Script strategy requires an LLM provider")
        return ScriptBuilder(llm_provider)

    elif strategy == BuildStrategy.PROCEDURALIZATION:
        if llm_provider is None:
            raise ValueError("Proceduralization strategy requires an LLM provider")
        return ProceduralizationBuilder(llm_provider)

    else:
        raise ValueError(f"Unknown build strategy: {strategy}")


# Export all builder classes and factory function
__all__ = [
    'MemoryBuilder',
    'TrajectoryBuilder',
    'ScriptBuilder',
    'ProceduralizationBuilder',
    'get_builder'
]
